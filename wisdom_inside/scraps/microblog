# current full url or full path in views and controllers

~~~ruby
    p request.fullpath
    "/foo/2/histories"

    p request.url
    "http://localhost:3000/foo/2/histories"
~~~

(REFERENCE)[http://stackoverflow.com/questions/2165665/how-to-get-current-url-in-rails]















# access view/helper methods in controller


~~~ruby
class UsersController < ApplicationController
  def destroy
    #...
    undo_link = view_context.link_to("undo", some_path)
    falsh[:notice] = "bla bla #{undo_link}"
    # ...
  end
end
~~~
















# rails 3 partial render allias

~~~ruby
= render 'addresses/search_fields', :f=>f
# is same (and shorter) than
= render  partial: 'addresses/search_fields', locals: {:f=>f}
~~~












# passing block to partial

I was looking for something like this

~~~haml
# app/views/posts/show.html.haml
= render 'box_top_nav' do
  'something else'
~~~

~~~haml 
# app/views/posts/_box_top_nav.html.haml
%div 
  .something
    'something'
= yield
~~~


...pass block to partial and render it. Example above  won't work of course, but this will

~~~haml
# app/views/posts/show.html.haml
= render :layout => 'box_top_nav' do
  'something'
~~~



(reference1){http://stackoverflow.com/questions/2951105/rails-render-partial-with-block}







# jasmine confirmation/alert dialog stub

if you have javascript functionality with confirmation dialog over it (e.g. delete link with confirmation) and you want to test the result after user click positive option (OK) with Jasmine, you need to stub (spy on) confirmation dialog like this 

~~~js
#app/assets/javascript/dialogs.js.cofee

widgetClose = (e) ->
  if confirm("are you surre")
     #... do something
~~~


#spec/javascript/dialogs.js.coffee
describe 'click on remove button', ->
  it 'should do some stuff' , ->
    #spyOn(window,"alert")
    spyOn(window,"confirm").andReturn(true)  #stub confirm dialog and simulate click OK
    $('.box-btn').trigger('click')  #triger drop
    #...
~~~




 Mock Devise current_user in helper specs

~~~ruby

module WidgetHelper 
  def render_widgets_for_column
    # ....
    current_user.widget_preferences  #Devise gem current user
    #....
    return some_content
  end
end

describe WidgetHelper do

  describe 'render_widgets_for_column' do 
    it 'should .... ' do
      mocked_user = double('User', widget_preferences: {foo: bar} )
      helper.stub(:current_user){mocked_user}

      helper.render_widgets_for_column.should ....
    end
  end

end

~~~











# How to wrap every second elements of array into Haml (HTML) tag

~~~ruby
- a = ['one', 'two', 'three', 'four']
- a.each do |element|
  .my_row
    = element

# <div class="row">one</div>
# <div class="row">two</div>
# <div class="row">three</div>
# <div class="row">four</div>

- a = ['one', 'two', 'three', 'four']
- a.each_slice(2) do |row|
  .my_row
   - row.each do |element|
    = element

# <div class="row">onetwo</div>
# <div class="row">threefour</div>
~~~

reference: http://stackoverflow.com/questions/2851915/rails-each-loop-insert-tag-every-6-items







# HashWithIndifferentAccess

in Rails 

~~~ruby
h = Hash.new
h['aaa'] = 'hello'

p h['aaa']
# hello

p h[:aaa]
#nil



hwia = HashWithIndifferentAccess.new
hwia['aaa'] = 'hello'

p hwia['aaa']
# hello

p hwia[:aaa]
# hello
~~~

*params* in rails controllers are also  indifferent access hash 








# default_scope

did you know there is *default_scope* functionality in Rails?

~~~ruby
class Article
  default_scope order('published_at')
end
~~~





# Rails flash notice Haml

~~~ruby
- flash.each do |name, msg|
  %div{:class => "alert alert-#{name == :notice ? "success" : "error"}"}
    %a.close{"data-dismiss" => "alert"} ×
    = content_tag :div, msg, :id => "flash_#{name}" if msg.is_a?(String)
~~~














## split string to char array

~~~ruby
"Hello, world!".scan(/./)
# => ["H", "e", "l", "l", "o", ",", " ", "w", "o", "r", "l", "d", "!"]
~~~



## print random number in formated string

### with with 4 char format

like:

    "90  "
    "590 "

do 

~~~ruby
col = rand(9999)
print printf( "%-4s",col)
~~~

much cooler approach 


~~~ruby
"%4s" % rand(9999)
"%-4s" % rand(9999)
~~~


### with leading zeros 4 char format

~~~ruby
"%04d" % rand(9999)
~~~

    "0010"
    "0300"

## removing whitespaces from string

    s = " a x  e \n"
    s.strip
    #=> "a x  e"
    s.chomp
    #=> " a x  e "


## remove nonasci characters from string 

If you wan't to remove nonasci characters from string like 

    s = "Grüße"

solution:

    s.gsub!(/\P{ASCII}/, '')

or 

    s.delete!("^\u{0000}-\u{007F}")
    #=> Gre













## oweride instance method that is asigned to alredy existing method


content is  method dynamicly created from ActiveRecord on comment table of Comment instance (content is column in db of table comments)

    Comment.new(:content => "\naaa\r")

now I want to remove new line chars from the string. The fastest solution is like this: 

    class Comment
      def content
        raw_content = super
        raw_content.delete("\n\r")
      end
    end

now this isn't best practice solution. I should create new method like *dislpay_content*  and just call *content.delete* there but there are som temporary refactore situations where this works ok


## install gems to local application directory

    bundle install --path vendor/bundle

this will create local bundle copy with gems and evrything needed 

        ▾ bundle/                      
          ▾ ruby/                      
            ▾ 1.9.1/                   
              ▸ bin/                   
              ▸ bundler/               
              ▸ cache/                 
              ▸ doc/                   
              ▸ gems/                                                                                                                     
              ▸ specifications/        
                .DS_Store              
              .DS_Store                
            .DS_Store                  
        ▸ plugins/     

